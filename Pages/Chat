import React, { useState, useEffect, useRef } from "react";
import { Conversation, Message } from "@/entities/all";
import { User } from "@/entities/User";
import { InvokeLLM } from "@/integrations/Core";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card } from "@/components/ui/card";
import { Send, Sparkles, Heart } from "lucide-react";
import { Skeleton } from "@/components/ui/skeleton";

import ChatMessage from "../components/chat/ChatMessage";
import WelcomeMessage from "../components/chat/WelcomeMessage";
import AnalysisCard from "../components/chat/AnalysisCard";

export default function ChatPage() {
  const [messages, setMessages] = useState([]);
  const [inputValue, setInputValue] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [conversation, setConversation] = useState(null);
  const [user, setUser] = useState(null);
  const [showAnalysis, setShowAnalysis] = useState(false);
  const messagesEndRef = useRef(null);

  useEffect(() => {
    initializeChat();
  }, []);

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  const initializeChat = async () => {
    try {
      const currentUser = await User.me();
      setUser(currentUser);

      // Chercher ou crÃ©er la conversation permanente
      const conversations = await Conversation.filter({ 
        type: "personal",
        created_by: currentUser.email 
      });

      let personalConv;
      if (conversations.length > 0) {
        personalConv = conversations[0];
      } else {
        personalConv = await Conversation.create({
          type: "personal",
          title: "Mon confident",
          participants: [currentUser.email]
        });
      }

      setConversation(personalConv);

      // Charger les messages
      const msgs = await Message.filter(
        { conversation_id: personalConv.id },
        "-created_date"
      );
      setMessages(msgs.reverse());
    } catch (error) {
      console.error("Erreur initialisation:", error);
    }
  };

  const sendMessage = async () => {
    if (!inputValue.trim() || isLoading || !conversation) return;

    const userMessage = inputValue.trim();
    setInputValue("");
    setIsLoading(true);

    try {
      // Ajouter le message utilisateur
      const newUserMessage = await Message.create({
        conversation_id: conversation.id,
        sender: "user",
        content: userMessage,
        sender_email: user.email
      });

      setMessages(prev => [...prev, newUserMessage]);

      // GÃ©nÃ©rer la rÃ©ponse IA
      const recentMessages = messages.slice(-10); // Contexte des 10 derniers messages
      const contextMessages = recentMessages.map(msg => 
        `${msg.sender === "user" ? "Vous" : "MÃ©diateur"}: ${msg.content}`
      ).join("\n");

      const aiResponse = await InvokeLLM({
        prompt: `Tu es un confident bienveillant et empathique. L'utilisateur te raconte sa journÃ©e, ses pensÃ©es, ses Ã©motions. Tu l'Ã©coutes avec attention, poses des questions pertinentes pour l'aider Ã  approfondir sa rÃ©flexion, et offres un soutien chaleureux.

Historique rÃ©cent de la conversation:
${contextMessages}

Nouveau message de l'utilisateur: ${userMessage}

RÃ©ponds de maniÃ¨re chaleureuse et bienveillante. Si l'utilisateur semble avoir un conflit ou un problÃ¨me relationnel, tu peux suggÃ©rer subtilement d'utiliser le bouton "Analyse & Conseil" pour une aide plus structurÃ©e.

Garde un ton naturel, comme un ami proche qui Ã©coute vraiment.`
      });

      // Ajouter la rÃ©ponse IA
      const aiMessage = await Message.create({
        conversation_id: conversation.id,
        sender: "ai",
        content: aiResponse
      });

      setMessages(prev => [...prev, aiMessage]);
    } catch (error) {
      console.error("Erreur envoi message:", error);
    }

    setIsLoading(false);
  };

  const generateAnalysis = async () => {
    if (!conversation || isLoading) return;
    
    setIsLoading(true);
    setShowAnalysis(true);

    try {
      const recentMessages = messages.slice(-20);
      const conversationHistory = recentMessages.map(msg => 
        `${msg.sender === "user" ? "Utilisateur" : "IA"}: ${msg.content}`
      ).join("\n\n");

      const analysis = await InvokeLLM({
        prompt: `Tu es un psychologue et mÃ©diateur professionnel. Analyse cette conversation rÃ©cente avec l'utilisateur et identifie:

1. **Ã‰tat Ã©motionnel** : Comment se sent la personne ?
2. **ProblÃ©matiques identifiÃ©es** : Quels sont les dÃ©fis ou conflits mentionnÃ©s ?
3. **Patterns comportementaux** : Y a-t-il des schÃ©mas rÃ©currents ?
4. **Besoins non exprimÃ©s** : Que cherche vraiment cette personne ?
5. **Pistes d'action** : Quelles suggestions concrÃ¨tes peux-tu donner ?

Historique de conversation:
${conversationHistory}

Fournis une analyse bienveillante et constructive, avec des questions pour aider la personne Ã  rÃ©flÃ©chir. Si tu dÃ©tectes un conflit relationnel, suggÃ¨re d'utiliser la fonction de mÃ©diation de groupe.

Sois empathique mais direct. Aide la personne Ã  voir plus clair.`,
        response_json_schema: {
          type: "object",
          properties: {
            emotional_state: { type: "string" },
            identified_issues: { type: "array", items: { type: "string" } },
            behavioral_patterns: { type: "array", items: { type: "string" } },
            unexpressed_needs: { type: "array", items: { type: "string" } },
            action_suggestions: { type: "array", items: { type: "string" } },
            reflection_questions: { type: "array", items: { type: "string" } },
            mediation_suggested: { type: "boolean" }
          }
        }
      });

      const analysisMessage = await Message.create({
        conversation_id: conversation.id,
        sender: "ai",
        content: `## ðŸ“Š Analyse de votre situation

**Ã‰tat Ã©motionnel :** ${analysis.emotional_state}

**ProblÃ©matiques identifiÃ©es :**
${analysis.identified_issues.map(issue => `â€¢ ${issue}`).join('\n')}

**Besoins dÃ©tectÃ©s :**
${analysis.unexpressed_needs.map(need => `â€¢ ${need}`).join('\n')}

**Suggestions d'action :**
${analysis.action_suggestions.map(action => `â€¢ ${action}`).join('\n')}

**Questions pour rÃ©flÃ©chir :**
${analysis.reflection_questions.map(q => `â€¢ ${q}`).join('\n')}

${analysis.mediation_suggested ? '\nðŸ’¡ **Il semble y avoir un conflit relationnel. Voulez-vous crÃ©er une mÃ©diation pour rÃ©soudre cette situation avec les autres personnes impliquÃ©es ?**' : ''}`
      });

      setMessages(prev => [...prev, analysisMessage]);
    } catch (error) {
      console.error("Erreur analyse:", error);
    }

    setIsLoading(false);
    setShowAnalysis(false);
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  };

  return (
    <div className="flex flex-col h-screen" style={{ backgroundColor: 'var(--background)' }}>
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.length === 0 ? (
          <WelcomeMessage />
        ) : (
          <>
            {messages.map((message) => (
              <ChatMessage 
                key={message.id} 
                message={message} 
                isUser={message.sender === "user"} 
              />
            ))}
          </>
        )}

        {isLoading && (
          <div className="flex justify-start">
            <Card className="p-4 max-w-sm">
              <div className="flex items-center gap-2">
                <Skeleton className="w-4 h-4 rounded-full" />
                <Skeleton className="w-4 h-4 rounded-full" />
                <Skeleton className="w-4 h-4 rounded-full" />
              </div>
            </Card>
          </div>
        )}

        <div ref={messagesEndRef} />
      </div>

      {messages.length > 5 && (
        <div className="p-4 border-t" style={{ borderColor: 'var(--border)' }}>
          <Button
            onClick={generateAnalysis}
            disabled={isLoading || showAnalysis}
            className="w-full mb-4"
            style={{
              backgroundColor: 'var(--primary)',
              color: 'var(--primary-foreground)'
            }}
          >
            <Sparkles className="w-4 h-4 mr-2" />
            {showAnalysis ? "Analyse en cours..." : "Analyse & Conseil"}
          </Button>
        </div>
      )}

      <div className="p-4 border-t" style={{ borderColor: 'var(--border)' }}>
        <div className="flex gap-2">
          <Input
            placeholder="Racontez-moi votre journÃ©e..."
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            onKeyPress={handleKeyPress}
            disabled={isLoading}
            className="flex-1"
            style={{
              borderColor: 'var(--border)',
              backgroundColor: 'var(--background)'
            }}
          />
          <Button 
            onClick={sendMessage}
            disabled={isLoading || !inputValue.trim()}
            style={{
              backgroundColor: 'var(--primary)',
              color: 'var(--primary-foreground)'
            }}
          >
            <Send className="w-4 h-4" />
          </Button>
        </div>
      </div>
    </div>
  )